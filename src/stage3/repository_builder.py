import os
from pathlib import Path
from typing import Dict, Any, List
from src.core.rpg import RepositoryPlanningGraph, NodeType
from src.utils.logger import StructuredLogger

logger = StructuredLogger("repository_builder")


class RepositoryBuilder:

    def __init__(self, output_dir: str, config: Dict[str, Any]):
        self.output_dir = Path(output_dir)
        self.config = config
        self.logger = logger

    def build(self, rpg: RepositoryPlanningGraph, generated_code: Dict[str, Dict]) -> str:
        """
        Build complete repository.

        Args:
            rpg: Complete RPG with file structure
            generated_code: Dict mapping node_id → {implementation, test_code}

        Returns:
            Path to generated repository
        """
        self.logger.log("info", "Building repository structure...")

        # Create output directory
        self.output_dir.mkdir(parents=True, exist_ok=True)

        # Step 1: Create folder structure
        self._create_folder_structure(rpg)

        # Step 2: Write all code files
        self._write_code_files(rpg, generated_code)

        # Step 3: Create package __init__.py files
        self._create_init_files(rpg)

        # Step 4: Write tests
        self._write_test_files(rpg, generated_code)

        # Step 5: Generate project files
        self._generate_project_files(rpg)

        self.logger.log("info", f"Repository built successfully at: {self.output_dir}")
        return str(self.output_dir)

    def _create_folder_structure(self, rpg: RepositoryPlanningGraph):
        """Create all folders from root nodes."""
        root_nodes = [n for n, d in rpg.graph.nodes(data=True) if d.get("type") == NodeType.ROOT.value]

        for node_id in root_nodes:
            node_data = rpg.graph.nodes[node_id]
            folder_path = node_data.get("file_path", "")

            if folder_path:
                full_path = self.output_dir / folder_path
                full_path.mkdir(parents=True, exist_ok=True)
                self.logger.log("debug", f"Created folder: {folder_path}")

        # Always create tests directory
        (self.output_dir / "tests").mkdir(exist_ok=True)

    def _write_code_files(self, rpg: RepositoryPlanningGraph, generated_code: Dict[str, Dict]):
        """Write all implementation files."""
        # Group code by file
        files_code = {}  # file_path → list of code snippets

        self.logger.log("debug", f"Processing {len(generated_code)} nodes for file writing")

        for node_id, code_data in generated_code.items():
            if node_id not in rpg.graph:
                self.logger.log("warning", f"Node {node_id} not in RPG graph - skipping")
                continue

            node_data = rpg.graph.nodes[node_id]
            file_path = node_data.get("file_path") or node_data.get("parent_file")
            node_name = node_data.get("name", node_id[:8])

            if not file_path:
                self.logger.log("warning", f"No file_path for node {node_name} - skipping")
                continue

            implementation = code_data.get("implementation", "")

            if not implementation:
                self.logger.log("warning", f"Empty implementation for {node_name} in {file_path}")
                continue

            if file_path not in files_code:
                files_code[file_path] = []

            files_code[file_path].append(implementation)
            self.logger.log("debug", f"Added code for {node_name} to {file_path}")

        # Write each file
        self.logger.log("info", f"Writing {len(files_code)} implementation files...")

        for file_path, code_snippets in files_code.items():
            full_path = self.output_dir / file_path

            # Ensure parent directory exists
            full_path.parent.mkdir(parents=True, exist_ok=True)

            # Collect imports
            all_imports = self._extract_imports(code_snippets)

            # Combine code
            file_content = self._combine_code_snippets(all_imports, code_snippets)

            # Write file
            full_path.write_text(file_content, encoding='utf-8')
            self.logger.log("info", f"Wrote file: {file_path}", lines=len(file_content.split('\n')))

    def _extract_imports(self, code_snippets: List[str]) -> List[str]:
        """Extract all import statements from code snippets."""
        imports = set()

        for code in code_snippets:
            for line in code.split('\n'):
                stripped = line.strip()
                if stripped.startswith('import ') or stripped.startswith('from '):
                    imports.add(stripped)

        return sorted(list(imports))

    def _combine_code_snippets(self, imports: List[str], code_snippets: List[str]) -> str:
        """Combine imports and code snippets into single file."""
        # File header
        content = '"""\nGenerated by BLUEPRINT\n"""\n\n'

        # Imports
        if imports:
            content += '\n'.join(imports) + '\n\n\n'

        # Code (remove import lines from snippets)
        for snippet in code_snippets:
            clean_code = '\n'.join([
                line for line in snippet.split('\n')
                if not (line.strip().startswith('import ') or line.strip().startswith('from '))
            ])
            content += clean_code + '\n\n'

        return content

    def _create_init_files(self, rpg: RepositoryPlanningGraph):
        """Create __init__.py for all packages."""
        root_nodes = [n for n, d in rpg.graph.nodes(data=True) if d.get("type") == NodeType.ROOT.value]

        for node_id in root_nodes:
            node_data = rpg.graph.nodes[node_id]
            folder_path = node_data.get("file_path", "")

            if folder_path:
                init_file = self.output_dir / folder_path / "__init__.py"

                # Collect public classes/functions for import
                exports = self._get_module_exports(rpg, node_id)

                # Write __init__.py
                init_content = f'"""\n{node_data.get("functionality", "")}\n"""\n\n'

                if exports:
                    init_content += f"__all__ = {exports}\n"

                init_file.write_text(init_content, encoding='utf-8')

    def _get_module_exports(self, rpg: RepositoryPlanningGraph, root_node_id: str) -> List[str]:
        """Get list of public exports for a module."""
        exports = []

        # Get all leaf nodes under this root
        for node_id in rpg.graph.nodes():
            node_data = rpg.graph.nodes[node_id]

            # Check if this node belongs to this module
            if node_data.get("type") == NodeType.LEAF.value:
                file_path = node_data.get("file_path") or node_data.get("parent_file", "")
                root_path = rpg.graph.nodes[root_node_id].get("file_path", "")

                if file_path.startswith(root_path):
                    name = node_data.get("name")
                    # Add if looks like a public name (not starting with _)
                    if name and not name.startswith('_'):
                        exports.append(name)

        return exports

    def _write_test_files(self, rpg: RepositoryPlanningGraph, generated_code: Dict[str, Dict]):
        """Write all test files."""
        # Group tests by source file
        tests_by_file = {}  # file_path → list of test code

        self.logger.log("debug", f"Processing {len(generated_code)} nodes for test writing")

        for node_id, code_data in generated_code.items():
            if node_id not in rpg.graph:
                continue

            node_data = rpg.graph.nodes[node_id]
            file_path = node_data.get("file_path") or node_data.get("parent_file")
            test_code = code_data.get("test_code", "")
            node_name = node_data.get("name", node_id[:8])

            if not file_path:
                self.logger.log("warning", f"No file_path for test of {node_name}")
                continue

            if not test_code:
                self.logger.log("warning", f"No test_code for {node_name}")
                continue

            if file_path not in tests_by_file:
                tests_by_file[file_path] = []

            tests_by_file[file_path].append(test_code)
            self.logger.log("debug", f"Added test for {node_name}")

        # Write test files
        self.logger.log("info", f"Writing {len(tests_by_file)} test files...")

        for file_path, test_snippets in tests_by_file.items():
            # Convert src/module/file.py → tests/test_module_file.py
            test_filename = self._get_test_filename(file_path)
            test_path = self.output_dir / "tests" / test_filename

            # Collect imports
            all_imports = self._extract_imports(test_snippets)

            # Combine tests
            test_content = '"""\nGenerated tests\n"""\n\n'
            test_content += '\n'.join(all_imports) + '\n\n\n'

            for snippet in test_snippets:
                clean_code = '\n'.join([
                    line for line in snippet.split('\n')
                    if not (line.strip().startswith('import ') or line.strip().startswith('from '))
                ])
                test_content += clean_code + '\n\n'

            test_path.write_text(test_content, encoding='utf-8')
            self.logger.log("info", f"Wrote test file: {test_filename}", lines=len(test_content.split('\n')))

    def _get_test_filename(self, source_file: str) -> str:
        """Convert source file path to test filename."""
        # src/data/loader.py → test_data_loader.py
        path = Path(source_file)
        name = path.stem
        parent = path.parent.name if path.parent.name != "src" else ""

        if parent:
            return f"test_{parent}_{name}.py"
        else:
            return f"test_{name}.py"

    def _generate_project_files(self, rpg: RepositoryPlanningGraph):
        """Generate setup.py, README.md, requirements.txt, etc."""
        repo_goal = rpg.repository_goal

        # Generate README.md
        readme_content = f"""# {repo_goal}

Generated by BLUEPRINT - Universal Repository Generation System

## Installation

```bash
pip install -r requirements.txt
```

## Usage

TODO: Add usage instructions

## Testing

```bash
pytest tests/
```

## Structure

TODO: Describe repository structure

## License

TODO: Add license information
"""
        (self.output_dir / "README.md").write_text(readme_content, encoding='utf-8')

        # Generate requirements.txt
        requirements = self._collect_requirements(rpg)
        (self.output_dir / "requirements.txt").write_text('\n'.join(requirements), encoding='utf-8')

        # Generate setup.py
        setup_content = f"""from setuptools import setup, find_packages

setup(
    name="{self._slugify(repo_goal)}",
    version="0.1.0",
    description="{repo_goal}",
    packages=find_packages(where="src"),
    package_dir={{"": "src"}},
    install_requires=[
{self._format_requirements_for_setup(requirements)}
    ],
    python_requires=">=3.11",
)
"""
        (self.output_dir / "setup.py").write_text(setup_content, encoding='utf-8')

        # Generate .gitignore
        gitignore_content = """__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
.pytest_cache/
.coverage
htmlcov/
.env
.venv
env/
venv/
"""
        (self.output_dir / ".gitignore").write_text(gitignore_content, encoding='utf-8')

        self.logger.log("info", "Generated project files: README.md, setup.py, requirements.txt, .gitignore")

    def _collect_requirements(self, rpg: RepositoryPlanningGraph) -> List[str]:
        """Collect all required Python packages."""
        requirements = set()

        for node_id, node_data in rpg.graph.nodes(data=True):
            imports = node_data.get("imports", [])
            for imp in imports:
                # Extract package name from import
                if imp.startswith('import '):
                    pkg = imp.split()[1].split('.')[0]
                    requirements.add(pkg)
                elif imp.startswith('from '):
                    pkg = imp.split()[1].split('.')[0]
                    requirements.add(pkg)

        # Map standard library imports to package names
        package_mapping = {
            "pd": "pandas",
            "np": "numpy",
            "plt": "matplotlib",
            "torch": "torch",
            "tf": "tensorflow",
        }

        mapped_requirements = set()
        for req in requirements:
            mapped = package_mapping.get(req, req)
            # Skip standard library
            if mapped not in ["typing", "os", "sys", "json", "re", "math", "random", "datetime", "pathlib"]:
                mapped_requirements.add(mapped)

        return sorted(list(mapped_requirements))

    def _format_requirements_for_setup(self, requirements: List[str]) -> str:
        """Format requirements for setup.py."""
        return ',\n'.join([f'        "{req}"' for req in requirements])

    def _slugify(self, text: str) -> str:
        """Convert text to slug (lowercase, underscores)."""
        return text.lower().replace(' ', '_').replace('-', '_')