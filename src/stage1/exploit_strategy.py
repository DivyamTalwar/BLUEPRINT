from typing import List, Dict, Any
from src.stage1.vector_store import VectorStore
from src.stage1.embedding_generator import EmbeddingGenerator
from src.stage1.user_input_processor import RepositoryRequest
from src.models.feature import Feature, ComplexityLevel
from src.utils.logger import get_logger
from src.utils.file_ops import FileOperations

logger = get_logger(__name__)


class ExploitStrategy:
    """Exploit strategy for focused feature retrieval"""

    def __init__(
        self,
        vector_store: VectorStore,
        embedding_generator: EmbeddingGenerator,
    ):
        """
        Initialize exploit strategy

        Args:
            vector_store: Vector database
            embedding_generator: Embedding generator
        """
        self.vector_store = vector_store
        self.embedding_generator = embedding_generator

    def retrieve_focused_features(
        self,
        request: RepositoryRequest,
        top_k: int = 10,
        use_domain_filter: bool = True,
    ) -> List[Feature]:
        """
        Retrieve features highly relevant to request

        Args:
            request: Repository request
            top_k: Number of features to retrieve
            use_domain_filter: Whether to filter by domain

        Returns:
            List of relevant features
        """
        if not request:
            raise ValueError("Repository request cannot be None")

        if top_k < 1 or top_k > 100:
            raise ValueError(f"top_k must be between 1 and 100, got {top_k}")

        logger.info("Exploit: Retrieving %d focused features", top_k)

        # Create search query from request
        query_text = self._build_query(request)

        # Generate embedding for query
        query_embedding = self.embedding_generator.generate_embedding(query_text)

        if not query_embedding:
            logger.error("Failed to generate query embedding")
            return []

        # Search with domain filter if requested
        if use_domain_filter and request.primary_domain:
            matches = self.vector_store.search_by_domain(
                query_embedding=query_embedding,
                domain=request.primary_domain,
                top_k=top_k,
            )
        else:
            matches = self.vector_store.search(
                query_embedding=query_embedding,
                top_k=top_k,
            )

        # Convert to Feature objects
        features = self._matches_to_features(matches)

        logger.info("Exploit: Retrieved %d features (avg score: %.3f)",
                   len(features),
                   sum(m["score"] for m in matches) / len(matches) if matches else 0)

        return features

    def retrieve_for_requirements(
        self,
        requirements: List[str],
        top_k_per_requirement: int = 5,
    ) -> List[Feature]:
        """
        Retrieve features for specific requirements

        Args:
            requirements: List of requirement descriptions
            top_k_per_requirement: Features per requirement

        Returns:
            Combined list of features
        """
        logger.info("Exploit: Retrieving features for %d requirements", len(requirements))

        all_features = []
        seen_ids = set()

        for req in requirements:
            # Generate embedding for requirement
            query_embedding = self.embedding_generator.generate_embedding(req)

            if not query_embedding:
                continue

            # Search
            matches = self.vector_store.search(
                query_embedding=query_embedding,
                top_k=top_k_per_requirement,
            )

            # Convert and deduplicate
            features = self._matches_to_features(matches)

            for feature in features:
                if feature.id not in seen_ids:
                    all_features.append(feature)
                    seen_ids.add(feature.id)

        logger.info("Exploit: Retrieved %d unique features for requirements",
                   len(all_features))

        return all_features

    def retrieve_by_complexity(
        self,
        request: RepositoryRequest,
        complexity: ComplexityLevel,
        top_k: int = 10,
    ) -> List[Feature]:
        """
        Retrieve features of specific complexity

        Args:
            request: Repository request
            complexity: Target complexity level
            top_k: Number of features

        Returns:
            Features of specified complexity
        """
        logger.info("Exploit: Retrieving %d features at %s complexity",
                   top_k, complexity.value)

        query_text = self._build_query(request)
        query_embedding = self.embedding_generator.generate_embedding(query_text)

        if not query_embedding:
            return []

        # Search with complexity filter
        matches = self.vector_store.search_by_complexity(
            query_embedding=query_embedding,
            complexity=complexity.value,
            top_k=top_k,
        )

        features = self._matches_to_features(matches)

        logger.info("Exploit: Retrieved %d features at %s complexity",
                   len(features), complexity.value)

        return features

    def retrieve_must_have_features(
        self,
        request: RepositoryRequest,
        top_k: int = 20,
    ) -> List[Feature]:
        """
        Retrieve absolutely essential features

        Args:
            request: Repository request
            top_k: Number of features

        Returns:
            Must-have features
        """
        logger.info("Exploit: Retrieving must-have features")

        # Focus on explicit and implicit requirements
        all_requirements = (
            request.explicit_requirements + request.implicit_requirements
        )

        # Retrieve features for each requirement
        features = self.retrieve_for_requirements(
            requirements=all_requirements[:10],  # Top 10 requirements
            top_k_per_requirement=2,  # 2 features per requirement
        )

        # Also retrieve from primary domain
        remaining = max(1, top_k - len(features))  # Ensure positive
        domain_features = self.retrieve_focused_features(
            request=request,
            top_k=remaining,
            use_domain_filter=True,
        )

        # Combine
        all_features = features + domain_features

        # Deduplicate
        seen = set()
        unique = []
        for f in all_features:
            if f.id not in seen:
                unique.append(f)
                seen.add(f.id)

        logger.info("Exploit: Retrieved %d must-have features", len(unique))

        return unique[:top_k]

    def _build_query(self, request: RepositoryRequest) -> str:
        """Build search query from request"""
        parts = [
            f"Repository type: {request.repo_type}",
            f"Domain: {request.primary_domain}",
        ]

        if request.explicit_requirements:
            parts.append(f"Requirements: {', '.join(request.explicit_requirements[:5])}")

        if request.implicit_requirements:
            parts.append(f"Implicit needs: {', '.join(request.implicit_requirements[:5])}")

        query = " | ".join(parts)

        logger.debug("Built query: %s", query[:200])

        return query

    def _matches_to_features(self, matches: List[Dict[str, Any]]) -> List[Feature]:
        """Convert vector search matches to Feature objects"""
        features = []

        for match in matches:
            metadata = match.get("metadata", {})

            # Parse keywords and use_cases
            keywords = metadata.get("keywords", "").split(",") if metadata.get("keywords") else []
            use_cases = metadata.get("use_cases", "").split(",") if metadata.get("use_cases") else []

            feature = Feature(
                id=match["id"],
                domain=metadata.get("domain", ""),
                subdomain=metadata.get("subdomain", ""),
                name=metadata.get("name", ""),
                description=metadata.get("description", ""),
                complexity=ComplexityLevel(metadata.get("complexity", "basic")),
                keywords=[k.strip() for k in keywords if k.strip()],
                use_cases=[u.strip() for u in use_cases if u.strip()],
                dependencies=[],
                embedding=None,  # Don't need embedding after retrieval
                metadata={"retrieval_score": match.get("score", 0.0)},
            )

            features.append(feature)

        return features
